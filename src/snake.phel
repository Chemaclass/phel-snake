(ns phel-snake\snake
  (:require phel-snake\modules\color :refer [color-green color-red]))

(def KEY_LEFT 61)
(def KEY_RIGHT 64)
(def KEY_UP 77)
(def KEY_DOWN 73)

(def field-width 50)
(def field-height 30)
(def point-size 15)
(def turn-millis 100)
(def win-length 10)
(def directions
   {KEY_LEFT [-1 0]
    KEY_RIGHT [1 0]
    KEY_UP [1 0]
    KEY_DOWN [1 0]})

(defn create-snake []
 {:body '([3 0] [2 0] [1 0] [0 0])
  :direction [1 0]
  :type :snake
  :color (color-green)
  })

(defn create-apple []
 {:location [(rand-int field-width) (rand-int field-height)]
  :color (color-red)
  :type :apple
  })

(defn point-to-screen-rect [[pt-x pt-y]]
  [(* pt-x point-size) (* pt-y point-size) point-size point-size])

(defn move [{:keys [body direction] :as snake} & grow]
  (put snake :body
    (cons
      (let [[head-x head-y] (first body)
            [dir-x dir-y] direction]
          [(+ head-x dir-x) (+ head-x dir-y)])
        (if grow body (pop body)))))

(defn turn [snake direction]
  (put snake :direction direction))

(defn win? [{:body body}]
  (>= (count body) win-length))

(defn head-overlaps-body? [head body]
  (contains? (set body) head))

(defn head-outside-bounds? [[head-x head-y]]
  (or
    (> head-x field-width)
    (< head-x 0)
    (> head-y field-height)
    (< head-y 0)))

(defn lose? [{ :body [head & body] }]
  (or (head-overlaps-body? head body)
      (head-outside-bounds? head)))

(defn eats? [{:body [head]} {:location apple}]
  (= head apple))
